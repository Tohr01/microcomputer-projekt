0010100000000000 ; [movi $0,0] COMMENT: CONSTANT: Stores number zero
0010100000100001 ; [movi $1,1] COMMENT: CONSTANT: Stores number one
0010100001011101 ; [movi $C1,29]
0001110001000101 ; [lsh $C1,5]
0000110001001001 ; [addi $C1,9]
0001110001000101 ; [lsh $C1,5]
0000110001010000 ; [addi $C1,16] COMMENT: CONSTANT: Amount of numbers we have to check corresponds to 30000
0010100001111111 ; [movi $C2,31]
0001110001100101 ; [lsh $C2,5]
0000110001101000 ; [addi $C2,8] COMMENT: CONSTANT: Starting address of numbering sequence for algorithm (= 1000)
0010010010000010 ; [mov $C3,$C1]
0000110010000010 ; [addi $C3,2] COMMENT: CONSTANT: Stores max number
0010010010100010 ; [mov $C4,$C1]
0000100010100011 ; [add $C4,$C2]
0001000010100001 ; [subi $C4,1] COMMENT: CONSTANT: Stores last valid address calculated by (numbers to write) + (starting address) - 1
0011010000100111 ; [call 39] COMMENT:  ;;; Line jumps to FILL_RAM
0010010011100011 ; [mov $CADDR,$C2] COMMENT: Store starting address in CADDR register
0011000100000111 ; [load $CNUM,$CADDR] COMMENT: Load number at $CADDR address from RAM in current num register
0011110100000000 ; [cmp $CNUM,$0]
0100100000100011 ; [je 35] COMMENT:  ;;; Line jumps to SIEVE_LOOP_NEXT_ITER
0010010100101000 ; [mov $MULLEFT,$CNUM]
0010010101001000 ; [mov $MULRIGHT,$CNUM]
0011010000110010 ; [call 50] COMMENT:  ;;; Line jumps to MULTIPLY
0011110011000001 ; [cmp $OVERFLOW,$1]
0100100001011011 ; [je 91] COMMENT:  ;;; Line jumps to OVERFLOW_HANDLING
0011110101100100 ; [cmp $MULRES,$C3]
0100010000100101 ; [jg 37] COMMENT:  ;;; Line jumps to NOOP_LOOP
0010010110000011 ; [mov $SADDR,$C2]
0001000110000010 ; [subi $SADDR,2]
0000100110001011 ; [add $SADDR,$MULRES]
0010110000001100 ; [store $0,$SADDR] COMMENT: Strike number / address
0000100110001000 ; [add $SADDR,$CNUM] COMMENT: Next multiple address
0011110110000101 ; [cmp $SADDR,$C4]
0100010000100011 ; [jg 35] COMMENT:  ;;; Line jumps to SIEVE_LOOP_NEXT_ITER
0100000000011110 ; [jmp 30] COMMENT:  ;;; Line jumps to STRIKE_MULTIPLES
0001010000000000 ; [incr $CADDR]
0100000000010001 ; [jmp 17] COMMENT:  ;;; Line jumps to SIEVE_LOOP
0000000000000000 ; [nop ]
0100000000100101 ; [jmp 37] COMMENT:  ;;; Line jumps to NOOP_LOOP
0010100110100000 ; [movi $R0,0] COMMENT: Iterator
0010100111000010 ; [movi $R1,2] COMMENT: Starting number
0010010111100011 ; [mov $R2,$C2] COMMENT: Starting address
0011110110100010 ; [cmp $R0,$C1] COMMENT: Compare iterator with max amount of numbers
0100100000110001 ; [je 49] COMMENT:  ;;; Line jumps to FILL_RAM_EXIT
0010110111001111 ; [store $R1,$R2] COMMENT: Store number
0001010000000000 ; [incr $R0] COMMENT: Increment iterator
0001010000000000 ; [incr $R1] COMMENT: Increment number to write
0001010000000000 ; [incr $R2] COMMENT: Increment address to write to
0100000000101010 ; [jmp 42] COMMENT:  ;;; Line jumps to FILL_RAM_LOOP
0011100000000000 ; [ret ]
0010100101100000 ; [movi $MULRES,0] COMMENT: set result to 0
0011110101000000 ; [cmp $MULRIGHT,$0] COMMENT: Compare multiplier with 0
0100100001011010 ; [je 90] COMMENT:  ;;; Line jumps to MULTIPLY_EXIT
0010010111001010 ; [mov $R1,$MULRIGHT] COMMENT: Copy data from MULRIGHT register to R1 register
0001100111000001 ; [andi $R1,1] COMMENT: If R1 is 1 then val in MULRIGHT is odd
0011110111000001 ; [cmp $R1,$1] COMMENT: Check if value in R1 == 1 (value in R2) Esentially if MULRIGHT is odd
0100100001010100 ; [je 84] COMMENT:  ;;; Line jumps to MULTIPLY_ADD_TO_RESULT
0001110100100001 ; [lsh $MULLEFT,1] COMMENT: $MULLEFT = $MULLEFT << 1
0010000101000001 ; [rsh $MULRIGHT,1] COMMENT: $MULRIGHT = $MULRIGHT >> 1
0100000001001001 ; [jmp 73] COMMENT:  ;;; Line jumps to MULTIPLY_LOOP
0000100101101001 ; [add $MULRES,$MULLEFT]
0100000001001111 ; [jmp 79] COMMENT:  ;;; Line jumps to MULTIPLY_SHIFT
0011100000000000 ; [ret ]
0010100101100000 ; [movi $MULRES,0] COMMENT: Set result to 0
0010100011000000 ; [movi $OVERFLOW,0] COMMENT: Initialize overflow flag to 0
0010100111100001 ; [movi $R2,1] COMMENT: Store one for comparison
0010101000011111 ; [movi $MAX_VALUE,31]
0001111000000101 ; [lsh $MAX_VALUE,5]
0000111000011111 ; [addi $MAX_VALUE,31]
0001111000000101 ; [lsh $MAX_VALUE,5]
0000111000011111 ; [addi $MAX_VALUE,31]
0001111000000101 ; [lsh $MAX_VALUE,5]
0000111000000001 ; [addi $MAX_VALUE,1] COMMENT: Max value for 16-bit (2^16 -1)? (= 65535)
0011110101000000 ; [cmp $MULRIGHT,$0] COMMENT: Compare multiplier with 0
0100100001011010 ; [je 90] COMMENT:  ;;; Line jumps to MULTIPLY_EXIT
0010010111001010 ; [mov $R1,$MULRIGHT] COMMENT: Copy data from MULRIGHT to R1
0001100111000001 ; [andi $R1,1] COMMENT: Check if MULRIGHT is odd
0011110111001111 ; [cmp $R1,$R2] COMMENT: Compare to 1 (odd check)
0100100001010100 ; [je 84] COMMENT:  ;;; Line jumps to MULTIPLY_ADD_TO_RESULT
0001110100100001 ; [lsh $MULLEFT,1] COMMENT: $MULLEFT = $MULLEFT << 1
0010000101000001 ; [rsh $MULRIGHT,1] COMMENT: $MULRIGHT = $MULRIGHT >> 1
0011110100110000 ; [cmp $MULLEFT,$MAX_VALUE]
0100010001011000 ; [jg 88] COMMENT:  ;;; Line jumps to MULTIPLY_OVERFLOW
0100000001001001 ; [jmp 73] COMMENT:  ;;; Line jumps to MULTIPLY_LOOP
0000100101101001 ; [add $MULRES,$MULLEFT] COMMENT: Add left to result
0011110101110000 ; [cmp $MULRES,$MAX_VALUE]
0100010001011000 ; [jg 88] COMMENT:  ;;; Line jumps to MULTIPLY_OVERFLOW
0100000001001111 ; [jmp 79] COMMENT:  ;;; Line jumps to MULTIPLY_SHIFT
0010100011000001 ; [movi $OVERFLOW,1] COMMENT: Set overflow flag
0011100000000000 ; [ret ] COMMENT: Exit multiplication
0011100000000000 ; [ret ] COMMENT: Return from multiplication
0100000000100101 ; [jmp 37] COMMENT:  ;;; Line jumps to NOOP_LOOP