0 0010100000000000 ; [movi $0,0] COMMENT: CONSTANT: Stores number zero
1 0010100000100001 ; [movi $1,1] COMMENT: CONSTANT: Stores number one
2 0010100001011101 ; [movi $C1,29]
3 0001110001000101 ; [lsh $C1,5]
4 0000110001001001 ; [addi $C1,9]
5 0001110001000101 ; [lsh $C1,5]
6 0000110001010000 ; [addi $C1,16] COMMENT: CONSTANT: Amount of numbers we have to check corresponds to 30000
7 0010100001111111 ; [movi $C2,31]
8 0001110001100101 ; [lsh $C2,5]
9 0000110001101000 ; [addi $C2,8] COMMENT: CONSTANT: Starting address of numbering sequence for algorithm (= 1000)
10 0010010010000010 ; [mov $C3,$C1]
11 0000110010000010 ; [addi $C3,2] COMMENT: CONSTANT: Stores max number
12 0010010010100010 ; [mov $C4,$C1]
13 0000100010100011 ; [add $C4,$C2]
14 0001000010100001 ; [subi $C4,1] COMMENT: CONSTANT: Stores last valid address calculated by (numbers to write) + (starting address) - 1
15 0011010000100111 ; [call 39] COMMENT:  ;;; Line jumps to FILL_RAM
16 0010010011100011 ; [mov $CADDR,$C2] COMMENT: Store starting address in CADDR register
17 0011000100000111 ; [load $CNUM,$CADDR] COMMENT: Load number at $CADDR address from RAM in current num register
18 0011110100000000 ; [cmp $CNUM,$0]
19 0100100000100011 ; [je 35] COMMENT:  ;;; Line jumps to SIEVE_LOOP_NEXT_ITER
20 0010010100101000 ; [mov $MULLEFT,$CNUM]
21 0010010101001000 ; [mov $MULRIGHT,$CNUM]
22 0011010000110010 ; [call 50] COMMENT:  ;;; Line jumps to MULTIPLY
23 0011110011000001 ; [cmp $OVERFLOW,$1]
24 0100100001011011 ; [je 91] COMMENT:  ;;; Line jumps to OVERFLOW_HANDLING
25 0011110101100100 ; [cmp $MULRES,$C3]
26 0100010000100101 ; [jg 37] COMMENT:  ;;; Line jumps to NOOP_LOOP
27 0010010110000011 ; [mov $SADDR,$C2]
28 0001000110000010 ; [subi $SADDR,2]
29 0000100110001011 ; [add $SADDR,$MULRES]
30 0010110000001100 ; [store $0,$SADDR] COMMENT: Strike number / address
31 0000100110001000 ; [add $SADDR,$CNUM] COMMENT: Next multiple address
32 0011110110000101 ; [cmp $SADDR,$C4]
33 0100010000100011 ; [jg 35] COMMENT:  ;;; Line jumps to SIEVE_LOOP_NEXT_ITER
34 0100000000011110 ; [jmp 30] COMMENT:  ;;; Line jumps to STRIKE_MULTIPLES
35 0001010000000000 ; [incr $CADDR]
36 0100000000010001 ; [jmp 17] COMMENT:  ;;; Line jumps to SIEVE_LOOP
37 0000000000000000 ; [nop ]
38 0100000000100101 ; [jmp 37] COMMENT:  ;;; Line jumps to NOOP_LOOP
39 0010100110100000 ; [movi $R0,0] COMMENT: Iterator
40 0010100111000010 ; [movi $R1,2] COMMENT: Starting number
41 0010010111100011 ; [mov $R2,$C2] COMMENT: Starting address
42 0011110110100010 ; [cmp $R0,$C1] COMMENT: Compare iterator with max amount of numbers
43 0100100000110001 ; [je 49] COMMENT:  ;;; Line jumps to FILL_RAM_EXIT
44 0010110111001111 ; [store $R1,$R2] COMMENT: Store number
45 0001010000000000 ; [incr $R0] COMMENT: Increment iterator
46 0001010000000000 ; [incr $R1] COMMENT: Increment number to write
47 0001010000000000 ; [incr $R2] COMMENT: Increment address to write to
48 0100000000101010 ; [jmp 42] COMMENT:  ;;; Line jumps to FILL_RAM_LOOP
49 0011100000000000 ; [ret ]
50 0010100101100000 ; [movi $MULRES,0] COMMENT: set result to 0
51 0011110101000000 ; [cmp $MULRIGHT,$0] COMMENT: Compare multiplier with 0
52 0100100001011010 ; [je 90] COMMENT:  ;;; Line jumps to MULTIPLY_EXIT
53 0010010111001010 ; [mov $R1,$MULRIGHT] COMMENT: Copy data from MULRIGHT register to R1 register
54 0001100111000001 ; [andi $R1,1] COMMENT: If R1 is 1 then val in MULRIGHT is odd
55 0011110111000001 ; [cmp $R1,$1] COMMENT: Check if value in R1 == 1 (value in R2) Esentially if MULRIGHT is odd
56 0100100001010100 ; [je 84] COMMENT:  ;;; Line jumps to MULTIPLY_ADD_TO_RESULT
57 0001110100100001 ; [lsh $MULLEFT,1] COMMENT: $MULLEFT = $MULLEFT << 1
58 0010000101000001 ; [rsh $MULRIGHT,1] COMMENT: $MULRIGHT = $MULRIGHT >> 1
59 0100000001001001 ; [jmp 73] COMMENT:  ;;; Line jumps to MULTIPLY_LOOP
60 0000100101101001 ; [add $MULRES,$MULLEFT]
61 0100000001001111 ; [jmp 79] COMMENT:  ;;; Line jumps to MULTIPLY_SHIFT
62 0011100000000000 ; [ret ]
63 0010100101100000 ; [movi $MULRES,0] COMMENT: Set result to 0
64 0010100011000000 ; [movi $OVERFLOW,0] COMMENT: Initialize overflow flag to 0
65 0010100111100001 ; [movi $R2,1] COMMENT: Store one for comparison
66 0010101000011111 ; [movi $MAX_VALUE,31]
67 0001111000000101 ; [lsh $MAX_VALUE,5]
68 0000111000011111 ; [addi $MAX_VALUE,31]
69 0001111000000101 ; [lsh $MAX_VALUE,5]
70 0000111000011111 ; [addi $MAX_VALUE,31]
71 0001111000000101 ; [lsh $MAX_VALUE,5]
72 0000111000000001 ; [addi $MAX_VALUE,1] COMMENT: Max value for 16-bit (2^16 -1)? (= 65535)
73 0011110101000000 ; [cmp $MULRIGHT,$0] COMMENT: Compare multiplier with 0
74 0100100001011010 ; [je 90] COMMENT:  ;;; Line jumps to MULTIPLY_EXIT
75 0010010111001010 ; [mov $R1,$MULRIGHT] COMMENT: Copy data from MULRIGHT to R1
76 0001100111000001 ; [andi $R1,1] COMMENT: Check if MULRIGHT is odd
77 0011110111001111 ; [cmp $R1,$R2] COMMENT: Compare to 1 (odd check)
78 0100100001010100 ; [je 84] COMMENT:  ;;; Line jumps to MULTIPLY_ADD_TO_RESULT
79 0001110100100001 ; [lsh $MULLEFT,1] COMMENT: $MULLEFT = $MULLEFT << 1
80 0010000101000001 ; [rsh $MULRIGHT,1] COMMENT: $MULRIGHT = $MULRIGHT >> 1
81 0011110100110000 ; [cmp $MULLEFT,$MAX_VALUE]
82 0100010001011000 ; [jg 88] COMMENT:  ;;; Line jumps to MULTIPLY_OVERFLOW
83 0100000001001001 ; [jmp 73] COMMENT:  ;;; Line jumps to MULTIPLY_LOOP
84 0000100101101001 ; [add $MULRES,$MULLEFT] COMMENT: Add left to result
85 0011110101110000 ; [cmp $MULRES,$MAX_VALUE]
86 0100010001011000 ; [jg 88] COMMENT:  ;;; Line jumps to MULTIPLY_OVERFLOW
87 0100000001001111 ; [jmp 79] COMMENT:  ;;; Line jumps to MULTIPLY_SHIFT
88 0010100011000001 ; [movi $OVERFLOW,1] COMMENT: Set overflow flag
89 0011100000000000 ; [ret ] COMMENT: Exit multiplication
90 0011100000000000 ; [ret ] COMMENT: Return from multiplication
91 0000010000000000 ; [hlt ]